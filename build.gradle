buildscript {
    repositories {
        mavenCentral()
        maven {
            name = "forge"
            url = "https://files.minecraftforge.net/maven"
        }
        maven {
            name = "sonatype"
            url = "https://oss.sonatype.org/content/repositories/snapshots/"
        }
        maven { url "https://jitpack.io" }
    }
    dependencies {
        classpath 'com.github.asbyth:ForgeGradle:6f5327738d'
    }
}

apply plugin: "net.minecraftforge.gradle.patcher"

minecraft {
    version = "1.8.9"
    mappings = 'stable_22'
    workspaceDir = "projects"
    versionJson = "jsons/1.8.9-dev.json"
    buildUserdev = true
    buildInstaller = true
    installerVersion = "1.5"

    def common = {
        patchPrefixOriginal "../src-base/minecraft"
        patchPrefixChanged "../src-work/minecraft"
        mainClassClient "net.minecraft.launchwrapper.Launch"
        tweakClassClient "net.minecraftforge.fml.common.launcher.FMLTweaker"
        mainClassServer "net.minecraft.launchwrapper.Launch"
        tweakClassServer "net.minecraftforge.fml.common.launcher.FMLServerTweaker"
    }

    projects {
        forge {
            rootDir "."
            patchDir "patches/minecraft"
            patchAfter "clean"
            genPatchesFrom "clean"
            genMcpPatches = false
            applyMcpPatches = false
            with common
        }
    }
}

group = 'net.minecraftforge'
version = getVersionFromJava(file("src/main/java/net/minecraftforge/common/ForgeVersion.java"))

extractForgeSources { exclude "**/SideOnly.java", "**/Side.java" }
extractForgeResources { exclude "**/log4j2.xml" }

genGradleProjects { addTestCompileDep "junit:junit:4.12" }

processJson {
    releaseJson = "jsons/1.8.9-rel.json"
    addReplacements([
        "@minecraft_version@": project.minecraft.version,
        "@version@"          : project.version,
        "@project@"          : "forge",
        "@artifact@"         : "net.minecraftforge:forge:${project.version}",
        "@universal_jar@"    : { outputJar.archiveName },
        "@timestamp@"        : new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
    ])
}

task changelog(type: JenkinsChangelog) {

    // skip if there is no forge jenkins pass
    onlyIf {
        project.hasProperty('forgeJenkinsPass')
    }

    outputs.upToDateWhen { false } // never up to date
    serverRoot = "https://ci.jenkins.minecraftforge.net/"
    jobName = "minecraftforge"
    targetBuild = System.env['BUILD_NUMBER'] ?: 0
    authName = "console_script"
    authPassword = project.hasProperty('forgeJenkinsPass') ? project.getProperty('forgeJenkinsPass') : ""
    output = "build/distributions/${project.name}-${project.version}-changelog.txt"
}

def extraTxts = [
    changelog, // yeah we can do thi, because gradle and groovy are awesome
    "licenses/LICENSE-fml.txt",
    "licenses/CREDITS-fml.txt",
    "licenses/MinecraftForge-Credits.txt",
    "licenses/MinecraftForge-License.txt",
    "licenses/Paulscode SoundSystem CodecIBXM License.txt",
    "licenses/Paulscode IBXM Library License.txt"
]

outputJar {
    archiveClassifier.set('universal')
    from extraTxts

    manifest.attributes([
        "Main-Class": "net.minecraftforge.fml.relauncher.ServerLaunchWrapper",
        "TweakClass": "net.minecraftforge.fml.common.launcher.FMLTweaker",
        "Class-Path": getServerClasspath(file("jsons/${minecraft.version}-rel.json"))
    ])
}

installer {
    archiveClassifier.set('installer')
    from extraTxts
    from "src/main/resources/forge_logo.png"
    rename "forge_logo\\.png", "big_logo.png"
}

task signUniversal(type: SignJar, dependsOn: 'outputJar') {
    onlyIf {
        project.hasProperty('jarsigner')
    }

    def jarsigner = [:]

    if (project.hasProperty('jarsigner'))
        jarsigner = project.jarsigner

    alias = 'forge'
    exclude "paulscode/**"
    storePass = jarsigner.storepass
    keyPass = jarsigner.keypass
    keyStore = jarsigner.keystore
    inputFile = outputJar.archiveFile
    outputFile = outputJar.archiveFile
}

build.dependsOn signUniversal
installer.dependsOn signUniversal

// HELPER METHODS

import groovy.json.JsonSlurper

String getServerClasspath(File file) {
    def node = new JsonSlurper().parse(file)
    def out = new StringBuilder()
    node.versionInfo.libraries.each { lib ->
        if (lib.serverreq) {
            // group : artifact : version
            def split = lib.name.split(':')
            def group = split[0].replace('.', '/')
            def artifact = split[1]
            def version = split[2]
            out += "libraries/$group/$artifact/$version/$artifact-${version}.jar "
        }
    }
    out += "minecraft_server.${minecraft.version}.jar"

    return out.toString()
}

@SuppressWarnings('GroovyMissingReturnStatement')
String getVersionFromJava(File file) {
    String major = "0"
    String minor = "0"
    String revision = "0"
    String build = "0"

    String prefix = "public static final int"
    file.eachLine { String s ->
        s = s.trim()
        if (s.startsWith(prefix)) {
            s = s.substring(prefix.length(), s.length() - 1)
            s = s.replace('=', ' ').replace("Version", "").replaceAll(" +", " ").trim()
            String[] pts = s.split(" ")

            if (pts[0] == "major") major = pts[pts.length - 1]
            else if (pts[0] == "minor") minor = pts[pts.length - 1]
            else if (pts[0] == "revision") revision = pts[pts.length - 1]
        }
    }

    if (System.getenv().containsKey("BUILD_NUMBER")) {
        build = System.getenv("BUILD_NUMBER")
    }

    def branch = null
    if (!System.getenv().containsKey("GIT_BRANCH")) {
        // TODO: use grgit
        branch = "git rev-parse --abbrev-ref HEAD".execute().text.trim()
    } else {
        branch = System.getenv("GIT_BRANCH")
        branch = branch.substring(branch.lastIndexOf('/') + 1)
    }

    def out = "${minecraft.version.replace('-', '_')}-$major.$minor.$revision.$build"

    if (branch && branch != 'master' && branch != 'HEAD')
        out += "-$branch"

    return out
}
